\chapter{Dynamic ARP Inspection Open Source}
Nel seguente capitolo viene descritta in dettaglio l'implementazione open source del software DAI, partendo dalla progettazione e passando allo sviluppo vero e proprio in linguaggio C.

    \section{Introduzione e Obiettivi Architetturali}
    L'obiettivo primario di questo progetto è replicare le funzionalità della Dynamic ARP Inspection in un'istanza simulata descritta nel Capitolo \ref{cap:ambiente_rete}, mantenendo efficienza e precisione. In tal senso, la scelta di eseguire l'implementazione in C rispecchiava pienamente i termini di efficienza per cui questo linguaggio è largamente utilizzato in questi contesti; inoltre, rende più agevole un'integrazione a basso livello nel firmware di apparati quali Switch Managed e Router.
    
    Un requisito rigorosamente immutabile rispetto all'attuale DAI è la validazione delle associazioni $\langle \text{IP, MAC} \rangle$, con conseguente rilevazione di un ARP Spoofing, in tempo reale. Questo è l'obiettivo al quale è stata data priorità assoluta, che ha determinato, a cascata, buona parte della natura architetturale del progetto. Di fatto, per garantire una rilevazione in tempo reale, è necessario implementare una struttura esente da operazioni ad alto overhead. Tale obiettivo è reso più sfidante dalla necessità di estrarre e memorizzare non solo l'associazione base $\langle \text{IP, MAC} \rangle$, ma anche l'indirizzo MAC del mittente effettivo $\langle \text{Sender MAC} \rangle$ direttamente dal frame Ethernet, un dato cruciale per la successiva tracciabilità dell'attaccante. Di seguito vengono descritte le scelte progettuali che hanno contribuito alla rilevazione istantanea di ARP Spoofing.

    La scelta di una struttura monolitica del progetto, senza multi-threading, comporterebbe una logica di elaborazione troppo basilare in un contesto in cui è necessario elaborare la ricezione, la memorizzazione e la validazione delle trame a livello data link. Tale struttura risulta semplicemente sottostimata rispetto al tasso di arrivo dei pacchetti di rete, comportando la perdita di una parte di essi e rallentando l'intero sistema. Nel progetto viene quindi preferita una struttura multi-thread che possa soddisfare questo bisogno di molteplici operazioni contemporaneamente.
    
    Sono state scartate le operazioni che coinvolgono l'interrogazione frequente del File System, che notoriamente comporta lunghe attese nei processi, a favore dell'implementazione di una cache temporanea che possa soddisfare le validazioni in modo molto più rapido. Questa scelta, in particolare nel contesto della validazione della trama, potrebbe comportare un rischio di sicurezza che verrà approfondito in seguito.

    Data la dinamicità delle informazioni da memorizzare ed elaborare, in particolare il numero di pacchetti acquisiti dalle interfacce di rete, risulta impraticabile utilizzare strutture dati statiche che necessitano di una dichiarazione anticipata dello spazio di memoria da allocare. Viene implementata l'allocazione dinamica delle strutture dati, grazie alla quale si ha un controllo più minuzioso dell'utilizzo della memoria e una flessibilità incomparabile.
    
    \section{Architettura Multi-Thread e Flusso Dati}
    L'architettura multi-thread è comunemente identificata con la programmazione concorrente. Questo tipo di processi ad elevato parallelismo esecutivo richiede interazioni tra i thread che devono essere gestite correttamente. Nel contesto della Dynamic ARP Inspection viene impiegato un primo tipo di \emph{thread ricevitori} per l'acquisizione delle trame a livello Data Link, una struttura dati condivisa tra i thread per memorizzare le associazioni complete, ovvero la tripla ⟨IP, MAC, Sender MAC⟩, e un numero variabile di \emph{thread analizzatori} che estrapolano le associazioni dalla memoria e le validano.

    Queste interazioni danno luogo a un pattern architetturale \cite{ardagna2012scalability} conosciuto come modello Produttore-Consumatore.  La Figura \ref{fig:diagr_prod_cons} schematizza il modello Produttore-Consumatore adottato per disaccoppiare la rapidità della ricezione di pacchetti (il Produttore) dalla latenza insita nel processo di analisi e validazione (il Consumatore).
    
    Per garantire l'integrità dei dati scambiati tra i due thread, il sistema richiede l'implementazione di robusti meccanismi di sincronizzazione e l'applicazione di regole ferree che regolano le due condizioni critiche: la disponibilità di spazio per l'accodamento e la presenza effettiva di un elemento da analizzare nella coda. Verranno approfonditi tali argomenti in seguito.

    \begin{figure}[H]
        \centering
        \includegraphics[width=1\linewidth]{immagini/Diagramma Architettura Produttore Consumatore.drawio.png}
        \caption{Diagramma Architettura Produttore Consumatore}
        \label{fig:diagr_prod_cons}
    \end{figure}

    Dopo aver definito l'architettura, è necessario delineare il ciclo di vita di un'associazione $\langle \text{IP, MAC} \rangle$ all'interno del sistema, il quale richiede l'interazione con componenti accessori oltre ai thread principali. Il Produttore (il thread ricevente) intercetta le trame a livello Data Link e, dopo una prima fase di parsing degli header essenziali, incapsula l'associazione in una struttura dati destinata alla coda. Da qui, l'associazione viene estratta dal Consumatore (il thread analizzatore) per la fase di validazione. 
    
    Cruciale per la correttezza del processo è la disponibilità di una base dati affidabile contenente le associazioni note e legittime. Pertanto, l'architettura include un terzo thread dedicato all'acquisizione e al mantenimento della cache delle lease DHCP. Questo thread gestisce l'accesso al File System e aggiorna la cache in memoria, isolando le lente operazioni di I/O dal percorso critico di analisi dei pacchetti. L'introduzione di questa base dati e del relativo thread di gestione completa il modello architetturale, garantendo che l'analizzatore operi sempre con informazioni aggiornate e coerenti.


    \section{Modulo di Acquisizione delle Trame e Utilizzo di Libpcap} 

    Il Modulo di Acquisizione delle Trame, implementato nel thread ricevente e contenuto nel file receiver.c, costituisce il punto d'ingresso del traffico di rete nel daemon di ispezione. La sua funzione è cruciale: agire come Produttore nel modello architetturale, intercettando selettivamente le trame ARP Reply e incapsulandole rapidamente in una struttura dati per l'analisi successiva. 
    
    Per realizzare un'acquisizione efficiente, l'implementazione si avvale della libreria Libpcap \cite{Libpcap_Doc}, che opera direttamente a livello Data Link e accede alla socket di rete con un overhead minimo. La scelta di libpcap è strategica, in quanto consente di scaricare gran parte del lavoro di scrematura dei pacchetti sul kernel del sistema operativo. Questo trasferimento di carico è ottenuto tramite l'applicazione di un filtro BPF (Berkeley Packet Filter) rigoroso, definito da: \texttt{arp and arp[7] == 2}. Tale filtro garantisce che il daemon riceva nello user space esclusivamente le trame di ARP Reply (Opcode=2), scartando tutto il resto del traffico,inclusi gli ARP Request e i pacchetti IP/TCP, prima che venga elaborato dal thread ricevente. Questa preselezione è fondamentale per mantenere elevato il throughput e prevenire la perdita di pacchetti. 
    
    Una volta intercettata la trama, il thread esegue un parsing essenziale. Oltre a estrarre i dati che compongono l'associazione base $\langle \text{IP, MAC} \rangle$ dall'intestazione ARP, il modulo acquisisce un elemento di sicurezza critico: l'indirizzo MAC del mittente $\langle \text{Sender MAC} \rangle$ direttamente dall'intestazione Ethernet. Questo dato è fondamentale poiché, in caso di rilevamento di un'associazione $\langle \text{IP, MAC} \rangle$ non valida (cioè, un MAC falso) all'interno del payload ARP, l'indirizzo MAC contenuto nell'Intestazione Ethernet corrisponde al dispositivo che ha effettivamente trasmesso il pacchetto. L'estrazione e la memorizzazione di entrambi i valori, il MAC dichiarato nel payload e il MAC mittente nel frame Ethernet, garantiscono che l'analizzatore non solo possa stabilire l'invalidità dell'associazione, ma possa anche identificare in modo tracciabile l'origine fisica dell'attacco di ARP Cache Poisoning. 
    
    Infine, l'associazione completa $\langle \text{IP, MAC, Sender MAC} \rangle$ viene accodata tramite la funzione \texttt{enqueue\_arp\_association}, completando il ruolo del Produttore e assicurando che la fase di ricezione non sia mai il collo di bottiglia dell'intero applicativo.

    \section{Implementazione della Coda Condivisa e Sincronizzazione}
    
    Il modulo \texttt{queue.c} implementa la coda centrale condivisa, elemento fondamentale per garantire l'efficacia del modello Produttore-Consumatore in un ambiente di ispezione di rete ad alta velocità. Questa struttura dati è realizzata come un buffer circolare (Ring Buffer) a capacità fissa, definita dalla costante \texttt{ARP\_QUEUE\_SIZE}. La scelta di un buffer circolare è dettata dall'esigenza di massimizzare l'efficienza della memoria, consentendo il riutilizzo dinamico dello spazio liberato senza richiedere costose operazioni di spostamento dei dati.

    Il meccanismo si basa sull'utilizzo di due puntatori interi, \texttt{head} e \texttt{tail}, e di un contatore \texttt{count} che traccia il numero attuale di elementi presenti. L'indice \texttt{tail} è gestito dal Produttore e indica la prossima posizione libera nel buffer, mentre l'indice \texttt{head} è gestito dal Consumatore e punta all'elemento più vecchio in attesa di essere processato. L'avanzamento di entrambi gli indici è controllato con l'operazione modulare (\texttt{\% ARP\_QUEUE\_SIZE}), che realizza in modo efficiente la proprietà First-In, First-Out (FIFO) della coda e rende effettiva la circolarità di quest'ultima.

    L'implementazione della concorrenza e di tutte le primitive di sincronizzazione del modello Produttore-Consumatore è stata realizzata tramite l'API POSIX Threads (pthread) \cite{POSIX_Pthreads}, la libreria standard per la gestione dei thread nell'ambiente C/Linux. L'uso di \texttt{pthread} consente di sfruttare i meccanismi di gestione della memoria condivisa e dello scheduling del sistema operativo in modo nativo ed efficiente. Il ricorso a questa libreria è essenziale per implementare le sezioni critiche e prevenire le race condition, garantendo che i thread di ricezione e di analisi possano accedere alla coda in modo sicuro e coordinato.
    
    Per garantire l'integrità dei dati in un ambiente multi-thread, dove entrambi i thread accedono e modificano simultaneamente gli indici e il contatore, tutte le operazioni critiche sono protette da un Mutex (\texttt{pthread\_mutex\_t mutex}). L'acquisizione del lock all'inizio di \texttt{enqueue\_arp\_association} e \texttt{dequeue\_arp\_association} impedisce le race condition e garantisce che ogni singola operazione di accesso o modifica alla coda sia trattata come atomica.
    
    A completamento del meccanismo di sincronizzazione, vengono utilizzate due Variabili di Condizione (\texttt{pthread\_cond\_t}), essenziali per la gestione delle condizioni limite del buffer. La variabile \texttt{not\_full} entra in gioco per gestire l'eccesso di traffico, bloccando il Produttore in attesa (tramite \texttt{pthread\_cond\_wait}) quando la coda raggiunge la sua capacità massima. Parallelamente, la variabile \texttt{not\_empty} blocca il Consumatore quando la coda è vuota, prevenendo letture non valide. L'uso congiunto di Mutex e Variabili di Condizione è fondamentale per l'efficienza: permette ai thread di dormire senza sprecare cicli di CPU in cicli di continua attesa e di essere risvegliati immediatamente tramite \texttt{pthread\_cond\_signal} non appena l'altro thread modifica lo stato della coda.

    All'interno della funzione \texttt{enqueue\_arp\_association}, l'implementazione ricorre all'allocazione dinamica di memoria per ogni singola associazione tramite \texttt{malloc} e al successivo copy bit a bit della struttura. Sebbene l'allocazione dinamica garantisca flessibilità, introduce un overhead leggermente superiore rispetto a una pre-allocazione statica; tuttavia, la strategia di delegare al thread analizzatore l'onere della deallocazione tramite \texttt{free\_arp\_association}, una volta che l'associazione è stata processata, isola l'operazione di liberazione di memoria dal thread ricevente, proteggendo il percorso critico di acquisizione dei pacchetti.
    
    \begin{table}[H]
        \centering
        \label{tab:sync_summary}
        \begin{tabular}{|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{4cm}|>{\raggedright\arraybackslash}p{5cm}|} 
            \hline
            \textbf{Meccanismo} & \textbf{Tipo} & \textbf{Descrizione e Scopo} \\
            \hline
            \texttt{pthread\_mutex\_t mutex} & Mutua Esclusione & Garantisce che un solo thread alla volta acceda alla coda, prevenendo la manipolazione concorrente di \texttt{head}, \texttt{tail} e \texttt{count}. \\
            \hline
            \texttt{pthread\_cond\_t not\_empty} & Variabile di Condizione & Sospende il thread Consumatore (\texttt{dequeue}) quando la coda è vuota, in attesa di un segnale dal Produttore. \\
            \hline
            \texttt{pthread\_cond\_t not\_full} & Variabile di Condizione & Sospende il thread Produttore (\texttt{enqueue}) quando la coda è piena, in attesa di un segnale dal Consumatore. \\
            \hline
            \textbf{Condizione Evitata} & \textbf{Definizione} & \textbf{Impatto sull'Applicazione di Rete} \\
            \hline
            Race Condition & Accesso concorrente ai dati condivisi. & Corruzione della coda (ad es., \texttt{head} o \texttt{tail} che puntano a valori errati), perdita di pacchetti ARP. \\
            \hline
            Active Waiting (Polling) & Thread che controlla continuamente una condizione. & Spreco di cicli CPU e aumento dell'overhead del sistema operativo, a discapito dell'efficienza. \\
            \hline
        \end{tabular}
        \caption{Riepilogo dei Meccanismi di Sincronizzazione e delle Condizioni}
    \end{table}
    
    
    \section{Modulo di Validazione (Analyzer)}
    Il Modulo di Validazione, la cui implementazione risiede nel file \texttt{analyzer.c}, costituisce il fulcro decisionale del sistema e opera in veste di Consumatore all'interno dell'architettura a thread concorrenti. Esso è primariamente responsabile dell'estrazione asincrona e dell'analisi della tripla associazione ⟨IP, MAC, Sender MAC⟩ contenuta nella coda condivisa. L'attivazione di ciascun thread analizzatore tramite la routine \texttt{analyzer\_thread} conferisce al sistema la necessaria scalabilità orizzontale, permettendo l'elaborazione simultanea di molteplici associazioni e mitigando così il rischio di backlog durante i picchi di traffico ARP.
    
    La routine del thread analizzatore è strutturata in un ciclo continuo che si avvia con la chiamata alla funzione \texttt{dequeue\_arp\_association}. In virtù delle primitive di sincronizzazione POSIX Threads impiegate nella coda, il thread Consumatore rimane in uno stato di sospensione senza consumare cicli di CPU in cicli di attesa attiva, venendo risvegliato esclusivamente quando il Produttore segnala la disponibilità di un nuovo elemento. Una volta estratta l'associazione, il thread ne assume la piena proprietà e la indirizza alla la validazione.
    
    La funzione \texttt{analyze\_arp\_association} incarna la logica di verifica, realizzando l'applicazione della Deny Policy del sistema attraverso l'interrogazione della Cache delle Lease DHCP. Infatti, con Deny Policy, si intende che ogni associazione ⟨IP, MAC⟩ ricevuta da un pacchetto ARP Reply è considerata non valida e non attendibile, fino a prova contraria. Il processo di validazione è articolato nel seguente modo.

    Il thread riceve un puntatore alla struttura \texttt{arp\_association\_t}. Successivamente, gli indirizzi MAC e IP vengono convertiti dal formato binario a quello di stringa, un'operazione necessaria per facilitare il lookup nella struttura dati della cache. La verifica è delegata alla funzione \texttt{lease\_cache\_check}, che interroga in tempo reale la cache residente in memoria. L'obiettivo è determinare se la coppia ⟨IP, MAC⟩ (ovvero, l'associazione dichiarata nel payload ARP) è stata precedentemente registrata come legittima dal server DHCP.

    Qualora la coppia ⟨IP, MAC⟩ sia riscontrata nella cache, l'associazione è ritenuta legittima e il processo analitico si conclude. Qualora si manifesti una discrepanza tra il MAC dichiarato nel payload ARP e quello atteso, si solleva un'eccezione di sicurezza, indicativa di un tentativo di ARP Cache Poisoning. In questo scenario, l'analizzatore sfrutta l'indirizzo Sender MAC, ottenuto dall'intestazione Ethernet, per registrare un alert e identificare in modo tracciabile l'origine fisica del pacchetto maligno.
    
    Al termine dell'analisi, il thread analizzatore adempie alla sua responsabilità di gestione della memoria, eseguendo la funzione \texttt{free\_arp\_association}. Tale azione dealloca la memoria precedentemente allocata dal Produttore con \texttt{malloc}, assicurando che la cooperazione nella gestione della memoria prevenga le perdite (\emph{memory leak}) e garantisca la stabilità del daemon durante l'esecuzione a lungo termine.
    
    \section{Validazione tramite File di Lease DHCP} 
    Il modulo \texttt{lease\_t.c} gestisce la componente statica di riferimento del sistema di Dynamic ARP Inspection, ovvero la Cache delle Lease DHCP. Questa cache rappresenta l'unica fonte attendibile per la verifica della legittimità delle associazioni ⟨IP, MAC⟩, garantendo dati autenticati. Per assolvere a questo compito, l'implementazione prevede un terzo thread dedicato (\texttt{lease\_updater\_thread}), il cui unico compito è isolare l'operazione lenta di I/O dal percorso critico di analisi dei pacchetti.
    
    Il thread updater opera a intervalli regolari, definiti in fase di configurazione, per leggere il file di lease DHCP del server, nel nostro caso \texttt{/var/lib/misc/dnsmasq.leases}, e aggiornare la struttura \texttt{lease\_cache\_t} allocata in memoria. Questo approccio previene che il thread analizzatore debba mai attendere operazioni di accesso al file system.
    
    La funzione \texttt{lease\_cache\_update} è il cuore del processo di I/O. Essa esegue l'apertura del file di lease e lo analizza riga per riga utilizzando \texttt{sscanf} all'interno della funzione statica \texttt{parse\_lease\_line}. Il parser estrae selettivamente gli indirizzi IP e MAC, ignorando i campi non essenziali per la validazione ARP, come il timestamp e l'hostname. Durante questo processo, viene allocata dinamicamente una nuova struttura dati \texttt{new\_entries} con capacità variabile attraverso \texttt{realloc}, permettendo alla cache di adattarsi in modo flessibile al numero di client attivi in rete.
    
    Cruciale per la robustezza del sistema è l'inclusione di una entry fissa per l'associazione ⟨IP, MAC⟩ del router all'inizio della nuova cache. Questa misura garantisce che la validazione dei pacchetti ARP inviati dal gateway di rete sia sempre effettuata, indipendentemente dalle dinamiche del servizio DHCP. Questa entry viene inizializzata in fase di avvio del daemon prima di caricare la cache dal file delle lease DHCP.
    
    Una volta completata la lettura e l'inserimento di tutte le lease valide nella struttura temporanea, avviene la fase di swap atomico. Il thread di aggiornamento acquisisce il Mutex dedicato alla cache (\texttt{cache->mutex}), libera la memoria della vecchia cache (\texttt{free(cache->entries)}), e riassegna il puntatore \texttt{cache->entries} alla nuova struttura. Il lock sulla cache è mantenuto solo per la brevissima durata di questa operazione di scambio, riducendo al minimo l'impatto sulla disponibilità dei dati per i thread analizzatori.
    
    La funzione \texttt{lease\_cache\_check} è l'unico punto di interazione tra il Modulo di Validazione e la Cache ed è progettata per la massima velocità. Il thread analizzatore invoca questa funzione passando l'IP e il MAC estratti dal pacchetto, e la funzione esegue una ricerca sequenziale diretta (\texttt{strcmp} e \texttt{strcasecmp}) attraverso la struttura dati in memoria. 
    
    Sebbene l'accesso esclusivo alla memoria RAM garantito dall'isolamento dell'I/O renda l'operazione intrinsecamente rapida, l'algoritmo di ricerca implementato è di tipo lineare. La complessità temporale di questa ricerca sequenziale, nel caso peggiore o nel caso medio in cui la lease non è trovata, è $O(n)$, dove $n$ è il numero totale di lease attive nella cache. Questa complessità, pur accettabile in ambienti di rete locali con un numero contenuto di host (generalmente $n<1000$), diventerebbe un fattore limitante in data center o reti aziendali di grandi dimensioni. In tali contesti, la costante di proporzionalità $n$ potrebbe compromettere i requisiti di latenza in tempo reale del sistema. 

    È tuttavia doveroso notare che, nelle reti aziendali, un elevato numero di host (con $n$ superiore alla soglia critica) è più frequente negli ambienti wireless Wi-Fi, dove la densità di utenti è concentrata. Nelle configurazioni cablate tradizionali, il numero di host per segmento di rete o VLAN è tipicamente inferiore e più gestibile. Negli ambienti Wi-Fi ad alta densità, è prassi comune segmentare la rete con punti di accesso (AP) multipli che operano su VLAN separate. Questo approccio divide il carico, mantenendo il valore di $n$, il numero di lease per specifica VLAN che il daemon monitora, al di sotto del limite critico che renderebbe la ricerca $O(n)$ impraticabile.    
    
    È fondamentale che anche la funzione di lookup acquisisca il Mutex della cache. Sebbene il thread analizzatore non modifichi la cache, l'acquisizione del Mutex impedisce che l'operazione di lookup avvenga simultaneamente all'operazione di swap da parte del thread updater. Tale sincronizzazione garantisce che ogni ricerca avvenga su una struttura dati integra e coerente. Il risultato (TRUE o FALSE) viene quindi restituito al thread analizzatore per la decisione finale di sicurezza, come discusso nel capitolo precedente.
    
    \section{Dettagli Implementativi e Struttura del Codice Sorgente}
    Nella presente sezione si presenta il cuore dei file sorgenti che compongono il programma. Ovviamente, tenuto conto della lunghezza, verranno presentati degli estratti delle principali funzionalità con relative descrizioni.

        \subsection{Implementazione del Receiver}
        
        Di seguito viene riportata la definizione della struttura dati utilizzata per passare gli argomenti al thread di ricezione:
        
        \begin{minted}[
            frame=lines,
            framesep=1mm,
            baselinestretch=1,
            bgcolor=codebg,
            fontsize=\footnotesize,
            % linenos
        ]{c}
        typedef struct {
            int num;
            pthread_mutex_t* stdout_mutex;
            char *interface;
            arp_association_queue_t *queue;
        } receiver_t_args;
        \end{minted}
        
        I campi della struttura \texttt{receiver\_t\_args} svolgono le seguenti funzioni:
        \begin{description}
            \item[\texttt{1. stdout\_mutex}] Puntatore al mutex per sincronizzare la stampa su terminale (debug).
            \item[\texttt{2. interface}] Stringa contenente il nome dell'interfaccia di rete (es. \texttt{enp0s8}).
            \item[\texttt{3. queue}] Puntatore alla coda thread-safe dove verranno inseriti i pacchetti ARP parsati.
        \end{description}
        
        Successivamente, il ciclo principale di acquisizione viene eseguito dalla funzione \texttt{receiver\_thread}. La funzione inizializza l'handle \texttt{pcap}, applica il filtro BPF per intercettare solo le ARP Reply ed entra in un loop infinito di ascolto:
        
        \begin{minted}[
            frame=lines,
            framesep=1mm,
            baselinestretch=1,
            bgcolor=codebg,
            fontsize=\footnotesize,
            % linenos,
            breaklines % Spezza le righe troppo lunghe automaticamente
        ]{c}
         void *receiver_thread(void *args) {
            receiver_t_args* t_args = (receiver_t_args *) args;
            pcap_t *handle;   
            struct bpf_program fp;   
            bpf_u_int32 net = 0;
        ...
            handle = pcap_open_live(t_args->interface, BUFSIZ, 1, 1000, errbuf);
            const char *arp_filter = "arp and arp[7] == 2";
            pcap_compile(handle, &fp, arp_filter, 1, net);
            pcap_setfilter(handle, &fp);
            struct pcap_pkthdr header;
            const unsigned char *packet;
            while (1) {
                packet = pcap_next(handle, &header){
                if (packet) {
                    if (header.caplen >= 14 + 28)
                        const unsigned char *mac_sender = packet + 6
                        const unsigned char *arp_header = packet + 14;
                        const unsigned char *mac_bind = arp_header + 8; 
                        const unsigned char *ip_bind = arp_header + 14; 
                        arp_association_t association;
                        memcpy(association.mac_addr, mac_bind, ETH_ALEN);
                        memcpy(&association.ip_addr, ip_bind, 4);
                        memcpy(association.mac_addr_sender, mac_sender, ETH_ALEN);
        ...
                        arp_association_queue_t *arp_queue = t_args->queue;
                        enqueue_arp_association(arp_queue, association);
                    }
               } 
            }
        }
        \end{minted}

    
    
    Tabella \ref{tab:sommario_file} riassuntiva dei file per una panoramica più completa.
    \begin{table}[h]
        \centering
        \begin{tabular}{|p{3cm}|p{8cm}|}
            \hline
            \textbf{File} & \textbf{Descrizione} \\
            \hline
            \texttt{main.c} & Inizializzazione del daemon, allocazione delle risorse condivise (coda e cache) e avvio dei thread \\
            \hline
            \texttt{queue.c} & Implementazione del Ring Buffer centrale e delle primitive di sincronizzazione Mutex e Variabili di Condizione \\
            \hline
            \texttt{receiver.c} & Acquisizione dei pacchetti ARP Reply a Livello 2 e inserimento nella coda condivisa \\
            \hline
            \texttt{analyzer.c} & Estrazione, parsing e validazione della tripla $\langle \text{IP, MAC, Sender MAC} \rangle$ tramite l'interrogazione della cache. \\
            \hline
            \texttt{lease\_t.c} & Implementazione del thread di aggiornamento periodico della Cache delle Lease DHCP (I/O)\\
            \hline
        \end{tabular}
        \caption{Sommario file del progetto}
        \label{tab:sommario_file}
    \end{table}

    \subsection{Librerie di Sviluppo C Utilizzate} % Qui citi pcap, pthread, ecc.

